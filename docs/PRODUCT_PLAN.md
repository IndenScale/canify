# Canify: 产品开发计划书

版本: 1.0 日期: 2025 年 10 月 15 日

## 1. 产品名称：Canify

核心理念: 源自 "Canon" (正典, 准则)，意为将项目的知识和规则“正典化”。

双关含义: "Can-ify" -> "Make it
possible"，寓意本产品使能（empower）大规模、高质量的协作，使其成为可能。

## 2. 愿景与使命 (Vision & Mission)

愿景: 成为下一代知识密集型项目的协作基石，将“文档即代码”的理念推广到所有行业，实现真正意义上的、可验证的“单一事实来源”。

使命: 提供一个强大的、自动化的校验与协作系统，将软件工程中成熟的质量保证体系（类型检查、依赖管理、CI/CD）无缝融入到结构化文档的生命周期中，赋能团队以前所未有的效率和信心管理复杂信息。

## 3. 核心架构与设计决策

### 3.1. 混合数据管理模型

事实来源 (Source of Truth): 版本控制的文本文件。实体统一使用带有 YAML Front
Matter 的 Markdown 文件进行定义，确保变更历史的透明性、可审查性，与 Git 工作流完美兼容。

性能索引 (Performance
Index): 一个本地、非版本化的嵌入式数据库 (SQLite)。作为事实来源的只读缓存，为大规模项目提供毫秒级的查询性能，驱动 IDE/Agent 的实时交互体验。

### 3.2. 语法体系

- 实体声明: 使用围栏代码块 (Fenced Code Block) +
  YAML 的形式，以保证对所有标准 Markdown 渲染器的完美兼容性。
- 实体引用: 使用自定义协议的标准 Markdown 链接
  [链接文本](entity://<ENTITY_ID>)，实现跨文档的、健壮的语义链接。

### 3.3. 多阶段验证引擎

引擎的阶段保持不变，但每个阶段的职责在质量门中的应用被重新划分。

- 阶段一：符号发现: 快速扫描，建立全局实体 ID 符号表。
- 阶段二：图构建与循环检测: 构建实体引用有向图，检测致命的循环依赖。
- 阶段三：实体内部验证 (Intra-Entity
  Validation): 使用 Pydantic 模型对单个实体的字段进行完整的类型、格式和必填项校验。
- 阶段四：实体间交叉验证 (Inter-Entity
  Validation): 执行 constraints 目录中定义的、需要多个实体上下文的复杂业务逻辑校验（例如，数额加总、父子状态依赖等）。

### 3.4. 分级质量门

我们重新定义了 Lax 和 Strict 模式的职责，使其更加贴合开发者的心智模型。

#### 引入“占位符” (Placeholder) 语法

我们约定一个或多个特殊的字符串值（例如 "TBD", "TODO",
"?"）作为占位符。当一个字段的值是占位符时，它将被特定阶段的校验器有意地忽略。这允许开发者明确地标记一个实体是“故意不完整的”，而不是“意外错误的”。

#### Lax 模式 (用于 pre-commit 钩子)

目标: 保证提交到本地版本历史的每个实体自身是结构正确的，并且项目的引用网络是健全的。

执行:

- 阶段一：符号发现
- 阶段二：图构建与循环检测
- 阶段三：实体内部验证

特殊规则: 在执行阶段三（实体内部验证）时，如果一个字段的值是占位符（如 "TBD"），则跳过对该字段的校验。例如，一个 points 字段类型要求是整数，但如果开发者写入 points:
"TBD"，Lax 模式会放行。

结果: 开发者无法提交一个意外的类型错误（如 points:
"five"），但可以有意地提交一个未完成的实体（points:
"TBD"）。这既捕获了低级错误，又保护了 WIP 的灵活性。

#### Strict 模式 (用于 CI/CD pre-merge 钩子)

目标: 保证合并到主分支的代码库在逻辑上是完全自洽和完整的。

执行:

- 执行所有 Lax 模式的检查。
- 阶段四：实体间交叉验证。

特殊规则:
Strict 模式禁止任何占位符的存在。在所有校验开始前，它会首先扫描是否存在 "TBD" 等值，如果发现，则立即报错。

结果: 任何未完成的工作（由占位符标记）都无法被合并，强制要求所有实体在进入主分支前必须达到“生产就绪”状态。
