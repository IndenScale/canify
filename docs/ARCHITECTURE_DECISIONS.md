# Canify 架构决策记录 (ADR)

版本: 1.1 日期: 2025-10-17

## 决策概览

| 决策编号 | 决策主题                 | 状态   | 日期       |
| -------- | ------------------------ | ------ | ---------- |
| ADR-001  | 编程语言选择             | 已确定 | 2025-10-16 |
| ADR-002  | 存储架构设计             | 已确定 | 2025-10-16 |
| ADR-003  | 统一验证引擎架构         | 已确定 | 2025-10-17 |
| ADR-004  | 三命令分层 CLI 接口设计  | 已确定 | 2025-10-17 |
| ADR-005  | 业务规则 Spec Schema 设计 | 已确定 | 2025-10-17 |

---

## ADR-001: 编程语言选择

### 状态

已确定 - 采用 Python + Pydantic，备选 Rust 热点优化

### 上下文

Canify 需要用户友好的实体定义体验，同时需要良好的 Agent 集成能力。用户更倾向于使用 Pydantic 来表达业务意图。

### 决策

#### 首选：Python + Pydantic

- 理由：Pydantic 提供优秀的用户体验、类型提示、丰富的验证生态
- 优势：快速原型、团队熟悉度、Agent 友好
- 策略：Python 原型验证价值，热点代码后续用 Rust 优化

#### 备选：Rust 热点优化

- 时机：当性能成为瓶颈时
- 范围：验证引擎、大规模查询等性能关键路径
- 原则：保持 Python 接口兼容性

### 后果

- 初期开发速度更快，用户体验更好
- 性能优化路径清晰，可渐进式改进
- 保持与 Pydantic 生态的紧密集成

---

## ADR-002: 存储架构设计

### 状态

已确定

### 上下文

需要同时支持版本控制的文本文件和高效的查询性能。

### 决策

采用分层存储架构：

1. **事实来源**: Markdown + YAML Front Matter 文件
2. **性能缓存**: SQLite 数据库
3. **企业扩展**: PostgreSQL/Redis (可选)

### 后果

- 数据一致性需要精心设计
- 缓存失效策略是关键
- 支持渐进式扩展

---

## ADR-003: 统一验证引擎架构

### 状态

已确定

### 上下文

需要支持从基础语法检查到复杂业务规则的渐进式验证，同时保持核心逻辑的内聚性和可维护性。

### 决策

采用**统一验证引擎 (`ValidationEngine`)** 架构。所有验证命令共享此引擎，并通过 `mode` 和 `strict` 参数调整其行为。引擎按以下四个固定阶段执行：

1. **符号发现 (Symbol Discovery)**: 扫描并解析所有实体声明，检查重复 ID。
2. **引用验证 (Reference Validation)**: 解析实体引用，检查悬空引用和循环依赖。
3. **Schema 验证 (Schema Validation)**: 验证实体内部的数据类型和值，并根据模式处理占位符（警告或错误）。
4. **业务规则验证 (Business Rule Validation)**: 加载并执行 `constraints/` 目录中定义的用户自定义业务规则。

### 后果

- **高度内聚**: 所有核心验证逻辑集中于一处，避免了功能分散。
- **行为可预测**: 不同命令的行为差异源于参数配置，而非完全不同的实现，使系统更易于理解和维护。
- **易于扩展**: 添加新的验证步骤只需在引擎的阶段流程中插入即可。

---

## ADR-004: 三命令分层 CLI 接口设计

### 状态

已确定

### 上下文

CLI 接口需要清晰地反映不同开发阶段的质量保证需求，从个人编辑到团队协作的最终合并。

### 决策

放弃早期 `query`, `search` 等多功能命令的设计，聚焦于验证功能，并设立三个核心命令，形成分层质量门：

- `canify lint`: **快速、宽松**。用于开发过程中的即时反馈，仅执行最基本的检查。
- `canify verify`: **中等、允许不完整**。用于代码提交（`pre-commit`）阶段，确保结构正确，但允许使用 "TBD" 等占位符。
- `canify validate`: **严格、完整**。用于合并请求（CI/CD）阶段，执行包括业务规则在内的最严格检查，且不允许任何占位符。

这三个命令共享同一个验证引擎，仅通过传入不同的 `mode` 参数来改变验证的深度和严格性。

### 后果

- **职责清晰**: 每个命令对应一个明确的开发场景，用户心智模型简单。
- **工作流集成**: 设计天然与 Git Hooks 和 CI/CD 流水线契合。
- **关注点分离**: 将验证功能做深做透，而不是追求大而全的命令集。

---

## ADR-005: 业务规则 Spec Schema 设计

### 状态

已确定

### 上下文

业务规则验证功能需要一种既能让非开发人员易于理解，又能让开发人员实现复杂逻辑的机制。

### 决策

采用**声明式 YAML + 过程式 Python** 的混合设计：

1.  **规则声明 (`constraints/spec_*.yaml`)**: 使用 YAML 文件来**声明**规则。这部分内容可读性高，清晰地定义了规则的 ID、名称、描述、以及在不同模式 (`verify`/`validate`) 下的严重级别 (`warning`/`error`)。

    ```yaml
    rules:
      - id: budget-allocation
        name: "预算分配约束"
        levels:
          verify: warning
          validate: error
        test_case: "business_rules.check_budget_allocation"
    ```

2.  **逻辑实现 (`constraints/test_cases/*.py`)**: `test_case` 字段指向一个 Python 函数。所有复杂的、过程式的检查逻辑都在 Python 代码中实现。这给予了开发者完全的灵活性，可以进行数据库查询、API 调用或任何复杂的算法计算。

### 后果

- **两全其美**: YAML 提供了高可读性的规则目录，而 Python 提供了无限的实现能力。
- **关注点分离**: 规则的“是什么”和“如何做”被清晰地分开。
- **易于协作**: 产品经理或架构师可以专注于编写和审查 YAML 中的规则声明，而开发人员则负责 Python 中的具体实现。

---

## 技术演进指南

### 性能优化路径

当 Python 原型性能不足时，按以下路径优化：

1. **第一阶段：Python 优化**

   - 使用 CPython 编译热点代码
   - 优化算法和数据结构
   - 并行处理大规模验证

2. **第二阶段：Rust 热点重构**
   - 验证引擎用 Rust 重写
   - 大规模查询性能优化
   - 通过 Python 绑定保持接口兼容

### 成功标准

- Python 原型在 2 周内完成核心功能验证
- 中小规模项目（1000 实体）验证时间 < 5 秒
- 用户能够使用 Pydantic 轻松定义实体模型
